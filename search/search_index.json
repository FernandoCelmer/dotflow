{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to dotflow This is a very simple library that is still in the early stages of development. The main goal of this tool is to create a simple and secure workflow for executing any type of task. The library's API design was made to make it easy to add tasks and control their execution. To keep it simple, just instantiate the DotFlow class, use the add method, and the start method to begin execution. Start with the basics here . Getting Help We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions. \ud83d\udc1b Bug Report \ud83d\udcd5 Documentation Issue \ud83d\ude80 Feature Request \ud83d\udcac General Question Commit Style \u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY License This project is licensed under the terms of the GNU General Public License v3.0.","title":"Home"},{"location":"#welcome-to-dotflow","text":"This is a very simple library that is still in the early stages of development. The main goal of this tool is to create a simple and secure workflow for executing any type of task. The library's API design was made to make it easy to add tasks and control their execution. To keep it simple, just instantiate the DotFlow class, use the add method, and the start method to begin execution. Start with the basics here .","title":"Welcome to dotflow"},{"location":"#getting-help","text":"We use GitHub issues for tracking bugs and feature requests and have limited bandwidth to address them. If you need anything, I ask you to please follow our templates for opening issues or discussions. \ud83d\udc1b Bug Report \ud83d\udcd5 Documentation Issue \ud83d\ude80 Feature Request \ud83d\udcac General Question","title":"Getting Help"},{"location":"#commit-style","text":"\u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY","title":"Commit Style"},{"location":"#license","text":"This project is licensed under the terms of the GNU General Public License v3.0.","title":"License"},{"location":"nav/getting-started/","text":"Getting Started February 10, 2025 Install To install Dotflow, run the following command from the command line: With Pip pip install dotflow With Poetry poetry add dotflow First Steps The simplest file could look like this: from dotflow import DotFlow, action, retry def my_callback(**kwargs): print(kwargs) @action @retry(max_retry=1) def my_task(): print(\"task\") workflow = DotFlow() workflow.task.add(step=my_task, callback=callback) workflow.start(workflow=workflow).sequential() 1 - Import Start with the basics, which is importing the necessary classes and methods. ( DotFlow , action , retry ) from dotflow import DotFlow, action, retry 2 - Callback function Create a my_callback function to receive execution information of a task. It is not necessary to include this function, as you will still have a report at the end of the execution in the instantiated object of the DotFlow class. This my_callback function is only needed if you need to do something after the execution of the task, for example: sending a message to someone, making a phone call, or sending a letter. def my_callback(**kwargs): print(kwargs) 3 - Task function Now create the function responsible for executing your task. It's very simple; just use the -> action decorator on top of the function, and that's it\u2014you've created a task. If necessary, you can also add another decorator called -> retry to set the maximum number of execution attempts if the function fails. @action @retry(max_retry=1) def my_task(): print(\"task\") 4 - DotFlow Class Instantiate the DotFlow class in a workflow variable to be used in the following steps. workflow = DotFlow() 5 - Add Task Now, simply add the my_task and my_callback functions you created earlier to the workflow using the code below. This process is necessary to define which tasks will be executed and the order in which they will run. The execution order follows the sequence in which they were added to the workflow. workflow.task.add(step=my_task, callback=callback) 6 - Start Finally, just execute the workflow with the following code snippet. workflow.start(workflow=workflow).sequential()","title":"Getting Started"},{"location":"nav/getting-started/#getting-started","text":"February 10, 2025","title":"Getting Started"},{"location":"nav/getting-started/#install","text":"To install Dotflow, run the following command from the command line:","title":"Install"},{"location":"nav/getting-started/#with-pip","text":"pip install dotflow","title":"With Pip"},{"location":"nav/getting-started/#with-poetry","text":"poetry add dotflow","title":"With Poetry"},{"location":"nav/getting-started/#first-steps","text":"The simplest file could look like this: from dotflow import DotFlow, action, retry def my_callback(**kwargs): print(kwargs) @action @retry(max_retry=1) def my_task(): print(\"task\") workflow = DotFlow() workflow.task.add(step=my_task, callback=callback) workflow.start(workflow=workflow).sequential()","title":"First Steps"},{"location":"nav/getting-started/#1-import","text":"Start with the basics, which is importing the necessary classes and methods. ( DotFlow , action , retry ) from dotflow import DotFlow, action, retry","title":"1 - Import"},{"location":"nav/getting-started/#2-callback-function","text":"Create a my_callback function to receive execution information of a task. It is not necessary to include this function, as you will still have a report at the end of the execution in the instantiated object of the DotFlow class. This my_callback function is only needed if you need to do something after the execution of the task, for example: sending a message to someone, making a phone call, or sending a letter. def my_callback(**kwargs): print(kwargs)","title":"2 - Callback function"},{"location":"nav/getting-started/#3-task-function","text":"Now create the function responsible for executing your task. It's very simple; just use the -> action decorator on top of the function, and that's it\u2014you've created a task. If necessary, you can also add another decorator called -> retry to set the maximum number of execution attempts if the function fails. @action @retry(max_retry=1) def my_task(): print(\"task\")","title":"3 - Task function"},{"location":"nav/getting-started/#4-dotflow-class","text":"Instantiate the DotFlow class in a workflow variable to be used in the following steps. workflow = DotFlow()","title":"4 - DotFlow Class"},{"location":"nav/getting-started/#5-add-task","text":"Now, simply add the my_task and my_callback functions you created earlier to the workflow using the code below. This process is necessary to define which tasks will be executed and the order in which they will run. The execution order follows the sequence in which they were added to the workflow. workflow.task.add(step=my_task, callback=callback)","title":"5 - Add Task"},{"location":"nav/getting-started/#6-start","text":"Finally, just execute the workflow with the following code snippet. workflow.start(workflow=workflow).sequential()","title":"6 - Start"},{"location":"nav/development/development-guide/","text":"Development Guide Commit Style \u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY","title":"Development Guide"},{"location":"nav/development/development-guide/#development-guide","text":"","title":"Development Guide"},{"location":"nav/development/development-guide/#commit-style","text":"\u2699\ufe0f FEATURE \ud83d\udcdd PEP8 \ud83d\udccc ISSUE \ud83e\udeb2 BUG \ud83d\udcd8 DOCS \ud83d\udce6 PyPI \u2764\ufe0f\ufe0f TEST \u2b06\ufe0f CI/CD \u26a0\ufe0f SECURITY","title":"Commit Style"},{"location":"nav/development/release-notes/","text":"Release Notes v0.1.0 \ud83d\udce6 PyPI - Build 0.1.0","title":"Release Notes"},{"location":"nav/development/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"nav/development/release-notes/#v010","text":"\ud83d\udce6 PyPI - Build 0.1.0","title":"v0.1.0"},{"location":"nav/learn/approaches/","text":"Mode of Action Sequential Background Parallel Data Storage","title":"Mode of Action"},{"location":"nav/learn/approaches/#mode-of-action","text":"","title":"Mode of Action"},{"location":"nav/learn/approaches/#sequential","text":"","title":"Sequential"},{"location":"nav/learn/approaches/#background","text":"","title":"Background"},{"location":"nav/learn/approaches/#parallel","text":"","title":"Parallel"},{"location":"nav/learn/approaches/#data-storage","text":"","title":"Data Storage"},{"location":"nav/reference/action-decorator/","text":"Action decorator Import You can import the action decorator directly from dotflow: from dotflow import action Example class dotflow.action @action def my_task(): print(\"task\")","title":"Action decorator"},{"location":"nav/reference/action-decorator/#action-decorator","text":"","title":"Action decorator"},{"location":"nav/reference/action-decorator/#import","text":"You can import the action decorator directly from dotflow: from dotflow import action","title":"Import"},{"location":"nav/reference/action-decorator/#example","text":"class dotflow.action @action def my_task(): print(\"task\")","title":"Example"},{"location":"nav/reference/context-class/","text":"Context class Here's the reference information for the Context class, with all its parameters, attributes and functions. Import You can import the Context class directly from dotflow: from dotflow import Context Example class dotflow.Context Context( storage={\"data\": [0, 1, 2, 3]} ) Parameters PARAMETER DESCRIPTION * storage Attribute where any type of Python object can be stored. TYPE : Any DEFAULT : None datetime Attribute available only for access; sending this parameter is not allowed. It will be assigned a value at runtime with the current date and time. TYPE : datetime DEFAULT : datetime.now","title":"Context class"},{"location":"nav/reference/context-class/#context-class","text":"Here's the reference information for the Context class, with all its parameters, attributes and functions.","title":"Context class"},{"location":"nav/reference/context-class/#import","text":"You can import the Context class directly from dotflow: from dotflow import Context","title":"Import"},{"location":"nav/reference/context-class/#example","text":"class dotflow.Context Context( storage={\"data\": [0, 1, 2, 3]} )","title":"Example"},{"location":"nav/reference/context-class/#parameters","text":"PARAMETER DESCRIPTION * storage Attribute where any type of Python object can be stored. TYPE : Any DEFAULT : None datetime Attribute available only for access; sending this parameter is not allowed. It will be assigned a value at runtime with the current date and time. TYPE : datetime DEFAULT : datetime.now","title":"Parameters"},{"location":"nav/reference/dotflow-class/","text":"Dotflow class Here's the reference information for the DotFlow class, with all its parameters, attributes and functions. Import You can import the Dotflow class directly from dotflow: from dotflow import DotFlow Example class dotflow.DotFlow DotFlow( title=\"My Workflow\", initial_context={\"data\": [0, 1, 2, 3]} ) Parameters PARAMETER DESCRIPTION title Reference title of the workflow. This title is used for documentation purposes and also for differentiation in contexts where many workflows are being executed. TYPE : string DEFAULT : \"\" initial_context The parameter has the main objective of including initial data in the execution of the workflow. This parameter can be accessed internally to retrieve this information and process it if necessary, according to the logic or objective of the workflow. TYPE : Any DEFAULT : Context Functions task class dotflow.DotFlow.task Function Description add start class dotflow.DotFlow.start Function Description sequential background parallel data_store","title":"Dotflow class"},{"location":"nav/reference/dotflow-class/#dotflow-class","text":"Here's the reference information for the DotFlow class, with all its parameters, attributes and functions.","title":"Dotflow class"},{"location":"nav/reference/dotflow-class/#import","text":"You can import the Dotflow class directly from dotflow: from dotflow import DotFlow","title":"Import"},{"location":"nav/reference/dotflow-class/#example","text":"class dotflow.DotFlow DotFlow( title=\"My Workflow\", initial_context={\"data\": [0, 1, 2, 3]} )","title":"Example"},{"location":"nav/reference/dotflow-class/#parameters","text":"PARAMETER DESCRIPTION title Reference title of the workflow. This title is used for documentation purposes and also for differentiation in contexts where many workflows are being executed. TYPE : string DEFAULT : \"\" initial_context The parameter has the main objective of including initial data in the execution of the workflow. This parameter can be accessed internally to retrieve this information and process it if necessary, according to the logic or objective of the workflow. TYPE : Any DEFAULT : Context","title":"Parameters"},{"location":"nav/reference/dotflow-class/#functions","text":"","title":"Functions"},{"location":"nav/reference/dotflow-class/#task","text":"class dotflow.DotFlow.task Function Description add","title":"task"},{"location":"nav/reference/dotflow-class/#start","text":"class dotflow.DotFlow.start Function Description sequential background parallel data_store","title":"start"},{"location":"nav/reference/retry-decorator/","text":"Retry decorator Import You can import the action decorator directly from dotflow: from dotflow import retry Example class dotflow.retry @action @retry(max_retry=1) def my_task(): print(\"task\") raise Exception(\"Task Error!\") Parameters PARAMETER DESCRIPTION * max_retry Maximum number of retries that the function should be executed if there is an error. TYPE : int DEFAULT : 1","title":"Retry decorator"},{"location":"nav/reference/retry-decorator/#retry-decorator","text":"","title":"Retry decorator"},{"location":"nav/reference/retry-decorator/#import","text":"You can import the action decorator directly from dotflow: from dotflow import retry","title":"Import"},{"location":"nav/reference/retry-decorator/#example","text":"class dotflow.retry @action @retry(max_retry=1) def my_task(): print(\"task\") raise Exception(\"Task Error!\")","title":"Example"},{"location":"nav/reference/retry-decorator/#parameters","text":"PARAMETER DESCRIPTION * max_retry Maximum number of retries that the function should be executed if there is an error. TYPE : int DEFAULT : 1","title":"Parameters"}]}